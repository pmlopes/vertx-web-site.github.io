{"pageProps":{"slug":"4.1.0/vertx-mssql-client/java","title":"Reactive MSSQL Client","fallbackGitHubStars":705,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_usage\">Usage</a></li>\n<li><a href=\"#_getting_started\">Getting started</a></li>\n<li><a href=\"#_connecting_to_sql_server\">Connecting to SQL Server</a></li>\n<li><a href=\"#_configuration\">Configuration</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_data_object\">Data Object</a></li>\n</ul>\n</li>\n<li><a href=\"#_running_queries\">Running queries</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_prepared_queries\">Prepared queries</a></li>\n<li><a href=\"#_batches\">Batches</a></li>\n</ul>\n</li>\n<li><a href=\"#_connect_retries\">Connect retries</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_connection_uri\">Connection URI</a></li>\n</ul>\n</li>\n<li><a href=\"#_tracing_queries\">Tracing queries</a></li>\n<li><a href=\"#_data_types_supported\">Data types supported</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_handling_enum\">Handling ENUM</a></li>\n</ul>\n</li>\n<li><a href=\"#_collector_queries\">Collector queries</a></li>\n</ul>\n</div>","contents":"<h1>Reactive MSSQL Client</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>The Reactive MSSQL Client is a client for Microsoft SQL Server with a straightforward API focusing on\nscalability and low overhead.</p>\n</div>\n<div class=\"paragraph\">\n<p><strong>Features</strong></p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Event driven</p>\n</li>\n<li>\n<p>Lightweight</p>\n</li>\n<li>\n<p>Built-in connection pooling</p>\n</li>\n<li>\n<p>Direct memory to object without unnecessary copies</p>\n</li>\n<li>\n<p>Java 8 Date and Time</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_usage\"><a class=\"anchor\" href=\"#_usage\"></a>Usage</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>To use the Reactive MSSQL Client add the following dependency to the <em>dependencies</em> section of your build descriptor:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven (in your <code>pom.xml</code>):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-mssql-client<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.1.0.Beta1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle (in your <code>build.gradle</code> file):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">dependencies {\n compile <span class=\"hljs-string\">'io.vertx:vertx-mssql-client:4.1.0.Beta1'</span>\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_getting_started\"><a class=\"anchor\" href=\"#_getting_started\"></a>Getting started</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Here is the simplest way to connect, query and disconnect</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">MSSQLConnectOptions connectOptions = <span class=\"hljs-keyword\">new</span> MSSQLConnectOptions()\n  .setPort(<span class=\"hljs-number\">1433</span>)\n  .setHost(<span class=\"hljs-string\">\"the-host\"</span>)\n  .setDatabase(<span class=\"hljs-string\">\"the-db\"</span>)\n  .setUser(<span class=\"hljs-string\">\"user\"</span>)\n  .setPassword(<span class=\"hljs-string\">\"secret\"</span>);\n\n<span class=\"hljs-comment\">// Pool options</span>\nPoolOptions poolOptions = <span class=\"hljs-keyword\">new</span> PoolOptions()\n  .setMaxSize(<span class=\"hljs-number\">5</span>);\n\n<span class=\"hljs-comment\">// Create the client pool</span>\nMSSQLPool client = MSSQLPool.pool(connectOptions, poolOptions);\n\n<span class=\"hljs-comment\">// A simple query</span>\nclient\n  .query(<span class=\"hljs-string\">\"SELECT * FROM users WHERE id='julien'\"</span>)\n  .execute(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    RowSet result = ar.result();\n    System.out.println(<span class=\"hljs-string\">\"Got \"</span> + result.size() + <span class=\"hljs-string\">\" rows \"</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n  }\n\n  <span class=\"hljs-comment\">// Now close the pool</span>\n  client.close();\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_connecting_to_sql_server\"><a class=\"anchor\" href=\"#_connecting_to_sql_server\"></a>Connecting to SQL Server</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Most of the time you will use a pool to connect to MSSQL:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">MSSQLConnectOptions connectOptions = <span class=\"hljs-keyword\">new</span> MSSQLConnectOptions()\n  .setPort(<span class=\"hljs-number\">1433</span>)\n  .setHost(<span class=\"hljs-string\">\"the-host\"</span>)\n  .setDatabase(<span class=\"hljs-string\">\"the-db\"</span>)\n  .setUser(<span class=\"hljs-string\">\"user\"</span>)\n  .setPassword(<span class=\"hljs-string\">\"secret\"</span>);\n\n<span class=\"hljs-comment\">// Pool options</span>\nPoolOptions poolOptions = <span class=\"hljs-keyword\">new</span> PoolOptions()\n  .setMaxSize(<span class=\"hljs-number\">5</span>);\n\n<span class=\"hljs-comment\">// Create the pooled client</span>\nMSSQLPool client = MSSQLPool.pool(connectOptions, poolOptions);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The pooled client uses a connection pool and any operation will borrow a connection from the pool\nto execute the operation and release it to the pool.</p>\n</div>\n<div class=\"paragraph\">\n<p>If you are running with Vert.x you can pass it your Vertx instance:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">MSSQLConnectOptions connectOptions = <span class=\"hljs-keyword\">new</span> MSSQLConnectOptions()\n  .setPort(<span class=\"hljs-number\">1433</span>)\n  .setHost(<span class=\"hljs-string\">\"the-host\"</span>)\n  .setDatabase(<span class=\"hljs-string\">\"the-db\"</span>)\n  .setUser(<span class=\"hljs-string\">\"user\"</span>)\n  .setPassword(<span class=\"hljs-string\">\"secret\"</span>);\n\n<span class=\"hljs-comment\">// Pool options</span>\nPoolOptions poolOptions = <span class=\"hljs-keyword\">new</span> PoolOptions()\n  .setMaxSize(<span class=\"hljs-number\">5</span>);\n<span class=\"hljs-comment\">// Create the pooled client</span>\nMSSQLPool client = MSSQLPool.pool(vertx, connectOptions, poolOptions);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>You need to release the pool when you don&#8217;t need it anymore:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">pool.close();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>When you need to execute several operations on the same connection, you need to use a client\n<code><a href=\"../../apidocs/io/vertx/mssqlclient/MSSQLConnection.html\">connection</a></code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>You can easily get one from the pool:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">MSSQLConnectOptions connectOptions = <span class=\"hljs-keyword\">new</span> MSSQLConnectOptions()\n  .setPort(<span class=\"hljs-number\">1433</span>)\n  .setHost(<span class=\"hljs-string\">\"the-host\"</span>)\n  .setDatabase(<span class=\"hljs-string\">\"the-db\"</span>)\n  .setUser(<span class=\"hljs-string\">\"user\"</span>)\n  .setPassword(<span class=\"hljs-string\">\"secret\"</span>);\n\n<span class=\"hljs-comment\">// Pool options</span>\nPoolOptions poolOptions = <span class=\"hljs-keyword\">new</span> PoolOptions()\n  .setMaxSize(<span class=\"hljs-number\">5</span>);\n\n<span class=\"hljs-comment\">// Create the pooled client</span>\nMSSQLPool client = MSSQLPool.pool(vertx, connectOptions, poolOptions);\n\n<span class=\"hljs-comment\">// Get a connection from the pool</span>\nclient.getConnection().compose(conn -&gt; {\n  System.out.println(<span class=\"hljs-string\">\"Got a connection from the pool\"</span>);\n\n  <span class=\"hljs-comment\">// All operations execute on the same connection</span>\n  <span class=\"hljs-keyword\">return</span> conn\n    .query(<span class=\"hljs-string\">\"SELECT * FROM users WHERE id='julien'\"</span>)\n    .execute()\n    .compose(res -&gt; conn\n      .query(<span class=\"hljs-string\">\"SELECT * FROM users WHERE id='emad'\"</span>)\n      .execute())\n    .onComplete(ar -&gt; {\n      <span class=\"hljs-comment\">// Release the connection to the pool</span>\n      conn.close();\n    });\n}).onComplete(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n\n    System.out.println(<span class=\"hljs-string\">\"Done\"</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Something went wrong \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Once you are done with the connection you must close it to release it to the pool, so it can be reused.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_configuration\"><a class=\"anchor\" href=\"#_configuration\"></a>Configuration</h2>\n<div class=\"sectionbody\">\n<div class=\"sect2\">\n<h3 id=\"_data_object\"><a class=\"anchor\" href=\"#_data_object\"></a>Data Object</h3>\n<div class=\"paragraph\">\n<p>A simple way to configure the client is to specify a <code>MSSQLConnectOptions</code> data object.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">MSSQLConnectOptions connectOptions = <span class=\"hljs-keyword\">new</span> MSSQLConnectOptions()\n  .setPort(<span class=\"hljs-number\">1433</span>)\n  .setHost(<span class=\"hljs-string\">\"the-host\"</span>)\n  .setDatabase(<span class=\"hljs-string\">\"the-db\"</span>)\n  .setUser(<span class=\"hljs-string\">\"user\"</span>)\n  .setPassword(<span class=\"hljs-string\">\"secret\"</span>);\n\n<span class=\"hljs-comment\">// Pool Options</span>\nPoolOptions poolOptions = <span class=\"hljs-keyword\">new</span> PoolOptions().setMaxSize(<span class=\"hljs-number\">5</span>);\n\n<span class=\"hljs-comment\">// Create the pool from the data object</span>\nMSSQLPool pool = MSSQLPool.pool(vertx, connectOptions, poolOptions);\n\npool.getConnection(ar -&gt; {\n  <span class=\"hljs-comment\">// Handling your connection</span>\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_running_queries\"><a class=\"anchor\" href=\"#_running_queries\"></a>Running queries</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>When you don&#8217;t need a transaction or run single queries, you can run queries directly on the pool; the pool\nwill use one of its connection to run the query and return the result to you.</p>\n</div>\n<div class=\"paragraph\">\n<p>Here is how to run simple queries:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .query(<span class=\"hljs-string\">\"SELECT * FROM users WHERE id='julien'\"</span>)\n  .execute(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    RowSet&lt;Row&gt; result = ar.result();\n    System.out.println(<span class=\"hljs-string\">\"Got \"</span> + result.size() + <span class=\"hljs-string\">\" rows \"</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_prepared_queries\"><a class=\"anchor\" href=\"#_prepared_queries\"></a>Prepared queries</h3>\n<div class=\"paragraph\">\n<p>You can do the same with prepared queries.</p>\n</div>\n<div class=\"paragraph\">\n<p>The SQL string can refer to parameters by position, using the database syntax {PREPARED_PARAMS}</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .preparedQuery(<span class=\"hljs-string\">\"SELECT * FROM users WHERE id=@p1\"</span>)\n  .execute(Tuple.of(<span class=\"hljs-string\">\"julien\"</span>), ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    RowSet&lt;Row&gt; rows = ar.result();\n    System.out.println(<span class=\"hljs-string\">\"Got \"</span> + rows.size() + <span class=\"hljs-string\">\" rows \"</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Query methods provides an asynchronous <code><a href=\"../../apidocs/io/vertx/sqlclient/RowSet.html\">RowSet</a></code> instance that works for <em>SELECT</em> queries</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .preparedQuery(<span class=\"hljs-string\">\"SELECT first_name, last_name FROM users\"</span>)\n  .execute(ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    RowSet&lt;Row&gt; rows = ar.result();\n    <span class=\"hljs-keyword\">for</span> (Row row : rows) {\n      System.out.println(<span class=\"hljs-string\">\"User \"</span> + row.getString(<span class=\"hljs-number\">0</span>) + <span class=\"hljs-string\">\" \"</span> + row.getString(<span class=\"hljs-number\">1</span>));\n    }\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>or <em>UPDATE</em>/<em>INSERT</em> queries:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .preparedQuery(<span class=\"hljs-string\">\"INSERT INTO users (first_name, last_name) VALUES (@p1, @p2)\"</span>)\n  .execute(Tuple.of(<span class=\"hljs-string\">\"Julien\"</span>, <span class=\"hljs-string\">\"Viet\"</span>), ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    RowSet&lt;Row&gt; rows = ar.result();\n    System.out.println(rows.rowCount());\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/sqlclient/Row.html\">Row</a></code> gives you access to your data by index</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">System.out.println(<span class=\"hljs-string\">\"User \"</span> + row.getString(<span class=\"hljs-number\">0</span>) + <span class=\"hljs-string\">\" \"</span> + row.getString(<span class=\"hljs-number\">1</span>));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>or by name</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">System.out.println(<span class=\"hljs-string\">\"User \"</span> + row.getString(<span class=\"hljs-string\">\"first_name\"</span>) + <span class=\"hljs-string\">\" \"</span> + row.getString(<span class=\"hljs-string\">\"last_name\"</span>));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The client will not do any magic here and the column name is identified with the name in the table regardless of how your SQL text is.</p>\n</div>\n<div class=\"paragraph\">\n<p>You can access a wide variety of of types</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">String firstName = row.getString(<span class=\"hljs-string\">\"first_name\"</span>);\nBoolean male = row.getBoolean(<span class=\"hljs-string\">\"male\"</span>);\nInteger age = row.getInteger(<span class=\"hljs-string\">\"age\"</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>You can use cached prepared statements to execute one-shot prepared queries:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">connectOptions.setCachePreparedStatements(<span class=\"hljs-keyword\">true</span>);\nclient\n  .preparedQuery(<span class=\"hljs-string\">\"SELECT * FROM users WHERE id = @p1\"</span>)\n  .execute(Tuple.of(<span class=\"hljs-string\">\"julien\"</span>), ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      RowSet&lt;Row&gt; rows = ar.result();\n      System.out.println(<span class=\"hljs-string\">\"Got \"</span> + rows.size() + <span class=\"hljs-string\">\" rows \"</span>);\n    } <span class=\"hljs-keyword\">else</span> {\n      System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n    }\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>You can create a <code>PreparedStatement</code> and manage the lifecycle by yourself.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">sqlConnection\n  .prepare(<span class=\"hljs-string\">\"SELECT * FROM users WHERE id = @p1\"</span>, ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      PreparedStatement preparedStatement = ar.result();\n      preparedStatement.query()\n        .execute(Tuple.of(<span class=\"hljs-string\">\"julien\"</span>), ar2 -&gt; {\n          <span class=\"hljs-keyword\">if</span> (ar2.succeeded()) {\n            RowSet&lt;Row&gt; rows = ar2.result();\n            System.out.println(<span class=\"hljs-string\">\"Got \"</span> + rows.size() + <span class=\"hljs-string\">\" rows \"</span>);\n            preparedStatement.close();\n          } <span class=\"hljs-keyword\">else</span> {\n            System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar2.cause().getMessage());\n          }\n        });\n    } <span class=\"hljs-keyword\">else</span> {\n      System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n    }\n  });</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_batches\"><a class=\"anchor\" href=\"#_batches\"></a>Batches</h3>\n<div class=\"paragraph\">\n<p>You can execute prepared batch</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">List&lt;Tuple&gt; batch = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\nbatch.add(Tuple.of(<span class=\"hljs-string\">\"julien\"</span>, <span class=\"hljs-string\">\"Julien Viet\"</span>));\nbatch.add(Tuple.of(<span class=\"hljs-string\">\"emad\"</span>, <span class=\"hljs-string\">\"Emad Alblueshi\"</span>));\n\n<span class=\"hljs-comment\">// Execute the prepared batch</span>\nclient\n  .preparedQuery(<span class=\"hljs-string\">\"INSERT INTO USERS (id, name) VALUES (@p1, @p2)\"</span>)\n  .executeBatch(batch, res -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n\n    <span class=\"hljs-comment\">// Process rows</span>\n    RowSet&lt;Row&gt; rows = res.result();\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">\"Batch failed \"</span> + res.cause());\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_connect_retries\"><a class=\"anchor\" href=\"#_connect_retries\"></a>Connect retries</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>You can configure the client to retry when a connection fails to be established.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">options\n  .setReconnectAttempts(<span class=\"hljs-number\">2</span>)\n  .setReconnectInterval(<span class=\"hljs-number\">1000</span>);</code></pre>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_connection_uri\"><a class=\"anchor\" href=\"#_connection_uri\"></a>Connection URI</h3>\n<div class=\"paragraph\">\n<p>As an alternative to configuring the client with a <code><a href=\"../../apidocs/io/vertx/mssqlclient/MSSQLConnectOptions.html\">MSSQLConnectOptions</a></code> data object, you can use a connection URI:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">String connectionUri = <span class=\"hljs-string\">\"sqlserver://dbuser:secretpassword@database.server.com:3211/mydb\"</span>;\n\n<span class=\"hljs-comment\">// Create the pool from the connection URI</span>\nMSSQLPool pool = MSSQLPool.pool(connectionUri);\n\n<span class=\"hljs-comment\">// Create the connection from the connection URI</span>\nMSSQLConnection.connect(vertx, connectionUri, res -&gt; {\n  <span class=\"hljs-comment\">// Handling your connection</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The connection URI format is defined by the client in an idiomatic way: <code>sqlserver://[user[:[password]]@]host[:port][/database][?attribute1=value1&amp;attribute2=value2&#8230;&#8203;]</code></p>\n</div>\n<div class=\"paragraph\">\n<p>Currently, the client supports the following parameter keywords in connection uri (keys are case-insensitive):</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>host</p>\n</li>\n<li>\n<p>port</p>\n</li>\n<li>\n<p>user</p>\n</li>\n<li>\n<p>password</p>\n</li>\n<li>\n<p>database</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_tracing_queries\"><a class=\"anchor\" href=\"#_tracing_queries\"></a>Tracing queries</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>The SQL client can trace query execution when Vert.x has tracing enabled.</p>\n</div>\n<div class=\"paragraph\">\n<p>The client reports the following <em>client</em> spans:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>Query</code> operation name</p>\n</li>\n<li>\n<p>tags</p>\n</li>\n<li>\n<p><code>db.user</code>: the database username</p>\n</li>\n<li>\n<p><code>db.instance</code>: the database instance</p>\n</li>\n<li>\n<p><code>db.statement</code>: the SQL query</p>\n</li>\n<li>\n<p><code>db.type</code>: <em>sql</em></p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>The default tracing policy is <code><a href=\"../../apidocs/io/vertx/core/tracing/TracingPolicy.html#PROPAGATE\">PROPAGATE</a></code>, the client\nwill only create a span when involved in an active trace.</p>\n</div>\n<div class=\"paragraph\">\n<p>You can change the client policy with <code><a href=\"../../apidocs/io/vertx/sqlclient/SqlConnectOptions.html#setTracingPolicy-io.vertx.core.tracing.TracingPolicy-\">setTracingPolicy</a></code>,\ne.g you can set <code><a href=\"../../apidocs/io/vertx/core/tracing/TracingPolicy.html#ALWAYS\">ALWAYS</a></code> to always report\na span:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">options.setTracingPolicy(TracingPolicy.ALWAYS);</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_data_types_supported\"><a class=\"anchor\" href=\"#_data_types_supported\"></a>Data types supported</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Currently, the client supports the following SQL Server types:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>TINYINT(<code>java.lang.Short</code>)</p>\n</li>\n<li>\n<p>SMALLINT(<code>java.lang.Short</code>)</p>\n</li>\n<li>\n<p>INT(<code>java.lang.Integer</code>)</p>\n</li>\n<li>\n<p>BIGINT(<code>java.lang.Long</code>)</p>\n</li>\n<li>\n<p>BIT(<code>java.lang.Boolean</code>)</p>\n</li>\n<li>\n<p>REAL(<code>java.lang.Float</code>)</p>\n</li>\n<li>\n<p>DOUBLE(<code>java.lang.Double</code>)</p>\n</li>\n<li>\n<p>NUMERIC/DECIMAL(<code><a href=\"../../apidocs/io/vertx/sqlclient/data/Numeric.html\">Numeric</a></code>)</p>\n</li>\n<li>\n<p>CHAR/VARCHAR(<code>java.lang.String</code>)</p>\n</li>\n<li>\n<p>NCHAR/NVARCHAR(<code>java.lang.String</code>)</p>\n</li>\n<li>\n<p>DATE(<code>java.time.LocalDate</code>)</p>\n</li>\n<li>\n<p>TIME(<code>java.time.LocalTime</code>)</p>\n</li>\n<li>\n<p>DATETIME2(<code>java.time.LocalDateTime</code>)</p>\n</li>\n<li>\n<p>DATETIMEOFFSET(<code>java.time.OffsetDateTime</code>)</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>Tuple decoding uses the above types when storing values</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_handling_enum\"><a class=\"anchor\" href=\"#_handling_enum\"></a>Handling ENUM</h3>\n<div class=\"paragraph\">\n<p>SQL Server does not have ENUM data type but the client can map the retrieved string/numeric data type to enum.</p>\n</div>\n<div class=\"paragraph\">\n<p>You can encode Java enums as String like this:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .preparedQuery(<span class=\"hljs-string\">\"INSERT INTO colors VALUES (@p1)\"</span>)\n  .execute(Tuple.of(Color.red),  res -&gt; {\n    <span class=\"hljs-comment\">// ...</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>You can retrieve the ENUM column as Java enums like this:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .preparedQuery(<span class=\"hljs-string\">\"SELECT color FROM colors\"</span>)\n  .execute()\n  .onComplete(res -&gt; {\n    <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n      RowSet&lt;Row&gt; rows = res.result();\n      <span class=\"hljs-keyword\">for</span> (Row row : rows) {\n        System.out.println(row.get(Color<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>, \"<span class=\"hljs-title\">color</span>\"))</span>;\n      }\n    }\n  });</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_collector_queries\"><a class=\"anchor\" href=\"#_collector_queries\"></a>Collector queries</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>You can use Java collectors with the query API:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Collector&lt;Row, ?, Map&lt;Long, String&gt;&gt; collector = Collectors.toMap(\n  row -&gt; row.getLong(<span class=\"hljs-string\">\"id\"</span>),\n  row -&gt; row.getString(<span class=\"hljs-string\">\"last_name\"</span>));\n\n<span class=\"hljs-comment\">// Run the query with the collector</span>\nclient.query(<span class=\"hljs-string\">\"SELECT * FROM users\"</span>)\n  .collecting(collector)\n  .execute(ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      SqlResult&lt;Map&lt;Long, String&gt;&gt; result = ar.result();\n\n      <span class=\"hljs-comment\">// Get the map created by the collector</span>\n      Map&lt;Long, String&gt; map = result.value();\n      System.out.println(<span class=\"hljs-string\">\"Got \"</span> + map);\n    } <span class=\"hljs-keyword\">else</span> {\n      System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n    }\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The collector processing must not keep a reference on the <code><a href=\"../../apidocs/io/vertx/sqlclient/Row.html\">Row</a></code> as\nthere is a single row used for processing the entire set.</p>\n</div>\n<div class=\"paragraph\">\n<p>The Java <code>Collectors</code> provides many interesting predefined collectors, for example you can\ncreate easily create a string directly from the row set:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Collector&lt;Row, ?, String&gt; collector = Collectors.mapping(\n  row -&gt; row.getString(<span class=\"hljs-string\">\"last_name\"</span>),\n  Collectors.joining(<span class=\"hljs-string\">\",\"</span>, <span class=\"hljs-string\">\"(\"</span>, <span class=\"hljs-string\">\")\"</span>)\n);\n\n<span class=\"hljs-comment\">// Run the query with the collector</span>\nclient.query(<span class=\"hljs-string\">\"SELECT * FROM users\"</span>)\n  .collecting(collector)\n  .execute(ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      SqlResult&lt;String&gt; result = ar.result();\n\n      <span class=\"hljs-comment\">// Get the string created by the collector</span>\n      String list = result.value();\n      System.out.println(<span class=\"hljs-string\">\"Got \"</span> + list);\n    } <span class=\"hljs-keyword\">else</span> {\n      System.out.println(<span class=\"hljs-string\">\"Failure: \"</span> + ar.cause().getMessage());\n    }\n  });</code></pre>\n</div>\n</div>\n</div>\n</div>","version":"4.1.0"},"__N_SSG":true}